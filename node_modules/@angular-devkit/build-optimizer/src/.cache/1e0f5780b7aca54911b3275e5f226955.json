{"remainingRequest":"E:\\Xavier\\Desenvolvimento\\Angular\\projeto\\serviço\\servico-online\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\Xavier\\Desenvolvimento\\Angular\\projeto\\serviço\\servico-online\\node_modules\\@angular\\animations\\fesm5\\animations.js","dependencies":[{"path":"E:\\Xavier\\Desenvolvimento\\Angular\\projeto\\serviço\\servico-online\\node_modules\\@angular\\animations\\fesm5\\animations.js","mtime":1528929345000},{"path":"E:\\Xavier\\Desenvolvimento\\Angular\\projeto\\serviço\\servico-online\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1529519366463},{"path":"E:\\Xavier\\Desenvolvimento\\Angular\\projeto\\serviço\\servico-online\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/**\r\n * @license Angular v6.0.5\r\n * (c) 2010-2018 Google, Inc. https://angular.io/\r\n * License: MIT\r\n */\r\n/**\r\n * AnimationBuilder is an injectable service that is available when the {@link\r\n * BrowserAnimationsModule BrowserAnimationsModule} or {@link NoopAnimationsModule\r\n * NoopAnimationsModule} modules are used within an application.\r\n *\r\n * The purpose if this service is to produce an animation sequence programmatically within an\r\n * angular component or directive.\r\n *\r\n * Programmatic animations are first built and then a player is created when the build animation is\r\n * attached to an element.\r\n *\r\n * ```ts\r\n * // remember to include the BrowserAnimationsModule module for this to work...\r\n * import {AnimationBuilder} from '@angular/animations';\r\n *\r\n * class MyCmp {\r\n *   constructor(private _builder: AnimationBuilder) {}\r\n *\r\n *   makeAnimation(element: any) {\r\n *     // first build the animation\r\n *     const myAnimation = this._builder.build([\r\n *       style({ width: 0 }),\r\n *       animate(1000, style({ width: '100px' }))\r\n *     ]);\r\n *\r\n *     // then create a player from it\r\n *     const player = myAnimation.create(element);\r\n *\r\n *     player.play();\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * When an animation is built an instance of {@link AnimationFactory AnimationFactory} will be\r\n * returned. Using that an {@link AnimationPlayer AnimationPlayer} can be created which can then be\r\n * used to start the animation.\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nvar AnimationBuilder = /*@__PURE__*/ (function () {\r\n    function AnimationBuilder() {\r\n    }\r\n    return AnimationBuilder;\r\n}());\r\n/**\r\n * An instance of `AnimationFactory` is returned from {@link AnimationBuilder#build\r\n * AnimationBuilder.build}.\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nvar AnimationFactory = /*@__PURE__*/ (function () {\r\n    function AnimationFactory() {\r\n    }\r\n    return AnimationFactory;\r\n}());\r\n/**\r\n * @experimental Animation support is experimental.\r\n */\r\nvar AUTO_STYLE = '*';\r\n/**\r\n * `trigger` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the\r\n * {@link Component#animations component animations metadata page} to gain a better\r\n * understanding of how animations in Angular are used.\r\n *\r\n * `trigger` Creates an animation trigger which will a list of {@link state state} and\r\n * {@link transition transition} entries that will be evaluated when the expression\r\n * bound to the trigger changes.\r\n *\r\n * Triggers are registered within the component annotation data under the\r\n * {@link Component#animations animations section}. An animation trigger can be placed on an element\r\n * within a template by referencing the name of the trigger followed by the expression value that\r\n the\r\n * trigger is bound to (in the form of `[@triggerName]=\"expression\"`.\r\n *\r\n * Animation trigger bindings strigify values and then match the previous and current values against\r\n * any linked transitions. If a boolean value is provided into the trigger binding then it will both\r\n * be represented as `1` or `true` and `0` or `false` for a true and false boolean values\r\n * respectively.\r\n *\r\n * ### Usage\r\n *\r\n * `trigger` will create an animation trigger reference based on the provided `name` value. The\r\n * provided `animation` value is expected to be an array consisting of {@link state state} and\r\n * {@link transition transition} declarations.\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   templateUrl: 'my-component-tpl.html',\r\n *   animations: [\r\n *     trigger(\"myAnimationTrigger\", [\r\n *       state(...),\r\n *       state(...),\r\n *       transition(...),\r\n *       transition(...)\r\n *     ])\r\n *   ]\r\n * })\r\n * class MyComponent {\r\n *   myStatusExp = \"something\";\r\n * }\r\n * ```\r\n *\r\n * The template associated with this component will make use of the `myAnimationTrigger` animation\r\n trigger by binding to an element within its template code.\r\n *\r\n * ```html\r\n * <!-- somewhere inside of my-component-tpl.html -->\r\n * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\r\n * ```\r\n *\r\n * ### Using an inline function\r\n * The `transition` animation method also supports reading an inline function which can decide\r\n * if its associated animation should be run.\r\n *\r\n * ```\r\n * // this method will be run each time the `myAnimationTrigger`\r\n * // trigger value changes...\r\n * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:\r\n string]: any}): boolean {\r\n *   // notice that `element` and `params` are also available here\r\n *   return toState == 'yes-please-animate';\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   templateUrl: 'my-component-tpl.html',\r\n *   animations: [\r\n *     trigger('myAnimationTrigger', [\r\n *       transition(myInlineMatcherFn, [\r\n *         // the animation sequence code\r\n *       ]),\r\n *     ])\r\n *   ]\r\n * })\r\n * class MyComponent {\r\n *   myStatusExp = \"yes-please-animate\";\r\n * }\r\n * ```\r\n *\r\n * The inline method will be run each time the trigger\r\n * value changes\r\n *\r\n * ## Disable Animations\r\n * A special animation control binding called `@.disabled` can be placed on an element which will\r\n then disable animations for any inner animation triggers situated within the element as well as\r\n any animations on the element itself.\r\n *\r\n * When true, the `@.disabled` binding will prevent all animations from rendering. The example\r\n below shows how to use this feature:\r\n *\r\n * ```ts\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   template: `\r\n *     <div [@.disabled]=\"isDisabled\">\r\n *       <div [@childAnimation]=\"exp\"></div>\r\n *     </div>\r\n *   `,\r\n *   animations: [\r\n *     trigger(\"childAnimation\", [\r\n *       // ...\r\n *     ])\r\n *   ]\r\n * })\r\n * class MyComponent {\r\n *   isDisabled = true;\r\n *   exp = '...';\r\n * }\r\n * ```\r\n *\r\n * The `@childAnimation` trigger will not animate because `@.disabled` prevents it from happening\r\n (when true).\r\n *\r\n * Note that `@.disabled` will only disable all animations (this means any animations running on\r\n * the same element will also be disabled).\r\n *\r\n * ### Disabling Animations Application-wide\r\n * When an area of the template is set to have animations disabled, **all** inner components will\r\n also have their animations disabled as well. This means that all animations for an angular\r\n application can be disabled by placing a host binding set on `@.disabled` on the topmost Angular\r\n component.\r\n *\r\n * ```ts\r\n * import {Component, HostBinding} from '@angular/core';\r\n *\r\n * @Component({\r\n *   selector: 'app-component',\r\n *   templateUrl: 'app.component.html',\r\n * })\r\n * class AppComponent {\r\n *   @HostBinding('@.disabled')\r\n *   public animationsDisabled = true;\r\n * }\r\n * ```\r\n *\r\n * ### What about animations that us `query()` and `animateChild()`?\r\n * Despite inner animations being disabled, a parent animation can {@link query query} for inner\r\n elements located in disabled areas of the template and still animate them as it sees fit. This is\r\n also the case for when a sub animation is queried by a parent and then later animated using {@link\r\n animateChild animateChild}.\r\n\r\n * ### Detecting when an animation is disabled\r\n * If a region of the DOM (or the entire application) has its animations disabled, then animation\r\n * trigger callbacks will still fire just as normal (only for zero seconds).\r\n *\r\n * When a trigger callback fires it will provide an instance of an {@link AnimationEvent}. If\r\n animations\r\n * are disabled then the `.disabled` flag on the event will be true.\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction trigger(name, definitions) {\r\n    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };\r\n}\r\n/**\r\n * `animate` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `animate` specifies an animation step that will apply the provided `styles` data for a given\r\n * amount of time based on the provided `timing` expression value. Calls to `animate` are expected\r\n * to be used within {@link sequence an animation sequence}, {@link group group}, or {@link\r\n * transition transition}.\r\n *\r\n * ### Usage\r\n *\r\n * The `animate` function accepts two input parameters: `timing` and `styles`:\r\n *\r\n * - `timing` is a string based value that can be a combination of a duration with optional delay\r\n * and easing values. The format for the expression breaks down to `duration delay easing`\r\n * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,\r\n * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the\r\n * `duration` value in millisecond form.\r\n * - `styles` is the style input data which can either be a call to {@link style style} or {@link\r\n * keyframes keyframes}. If left empty then the styles from the destination state will be collected\r\n * and used (this is useful when describing an animation step that will complete an animation by\r\n * {@link transition#the-final-animate-call animating to the final state}).\r\n *\r\n * ```typescript\r\n * // various functions for specifying timing data\r\n * animate(500, style(...))\r\n * animate(\"1s\", style(...))\r\n * animate(\"100ms 0.5s\", style(...))\r\n * animate(\"5s ease\", style(...))\r\n * animate(\"5s 10ms cubic-bezier(.17,.67,.88,.1)\", style(...))\r\n *\r\n * // either style() of keyframes() can be used\r\n * animate(500, style({ background: \"red\" }))\r\n * animate(500, keyframes([\r\n *   style({ background: \"blue\" })),\r\n *   style({ background: \"red\" }))\r\n * ])\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction animate(timings, styles) {\r\n    if (styles === void 0) {\r\n        styles = null;\r\n    }\r\n    return { type: 4 /* Animate */, styles: styles, timings: timings };\r\n}\r\n/**\r\n * `group` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are\r\n * useful when a series of styles must be animated/closed off at different starting/ending times.\r\n *\r\n * The `group` function can either be used within a {@link sequence sequence} or a {@link transition\r\n * transition} and it will only continue to the next instruction once all of the inner animation\r\n * steps have completed.\r\n *\r\n * ### Usage\r\n *\r\n * The `steps` data that is passed into the `group` animation function can either consist of {@link\r\n * style style} or {@link animate animate} function calls. Each call to `style()` or `animate()`\r\n * within a group will be executed instantly (use {@link keyframes keyframes} or a {@link\r\n * animate#usage animate() with a delay value} to offset styles to be applied at a later time).\r\n *\r\n * ```typescript\r\n * group([\r\n *   animate(\"1s\", { background: \"black\" }))\r\n *   animate(\"2s\", { color: \"white\" }))\r\n * ])\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction group(steps, options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 3 /* Group */, steps: steps, options: options };\r\n}\r\n/**\r\n * `sequence` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by\r\n * default when an array is passed as animation data into {@link transition transition}.)\r\n *\r\n * The `sequence` function can either be used within a {@link group group} or a {@link transition\r\n * transition} and it will only continue to the next instruction once each of the inner animation\r\n * steps have completed.\r\n *\r\n * To perform animation styling in parallel with other animation steps then have a look at the\r\n * {@link group group} animation function.\r\n *\r\n * ### Usage\r\n *\r\n * The `steps` data that is passed into the `sequence` animation function can either consist of\r\n * {@link style style} or {@link animate animate} function calls. A call to `style()` will apply the\r\n * provided styling data immediately while a call to `animate()` will apply its styling data over a\r\n * given time depending on its timing data.\r\n *\r\n * ```typescript\r\n * sequence([\r\n *   style({ opacity: 0 })),\r\n *   animate(\"1s\", { opacity: 1 }))\r\n * ])\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction sequence(steps, options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 2 /* Sequence */, steps: steps, options: options };\r\n}\r\n/**\r\n * `style` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `style` declares a key/value object containing CSS properties/styles that can then be used for\r\n * {@link state animation states}, within an {@link sequence animation sequence}, or as styling data\r\n * for both {@link animate animate} and {@link keyframes keyframes}.\r\n *\r\n * ### Usage\r\n *\r\n * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs\r\n * to be defined.\r\n *\r\n * ```typescript\r\n * // string values are used for css properties\r\n * style({ background: \"red\", color: \"blue\" })\r\n *\r\n * // numerical (pixel) values are also supported\r\n * style({ width: 100, height: 0 })\r\n * ```\r\n *\r\n * #### Auto-styles (using `*`)\r\n *\r\n * When an asterix (`*`) character is used as a value then it will be detected from the element\r\n * being animated and applied as animation data when the animation starts.\r\n *\r\n * This feature proves useful for a state depending on layout and/or environment factors; in such\r\n * cases the styles are calculated just before the animation starts.\r\n *\r\n * ```typescript\r\n * // the steps below will animate from 0 to the\r\n * // actual height of the element\r\n * style({ height: 0 }),\r\n * animate(\"1s\", style({ height: \"*\" }))\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction style(tokens) {\r\n    return { type: 6 /* Style */, styles: tokens, offset: null };\r\n}\r\n/**\r\n * `state` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `state` declares an animation state within the given trigger. When a state is active within a\r\n * component then its associated styles will persist on the element that the trigger is attached to\r\n * (even when the animation ends).\r\n *\r\n * To animate between states, have a look at the animation {@link transition transition} DSL\r\n * function. To register states to an animation trigger please have a look at the {@link trigger\r\n * trigger} function.\r\n *\r\n * #### The `void` state\r\n *\r\n * The `void` state value is a reserved word that angular uses to determine when the element is not\r\n * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the\r\n * associated element is void).\r\n *\r\n * #### The `*` (default) state\r\n *\r\n * The `*` state (when styled) is a fallback state that will be used if the state that is being\r\n * animated is not declared within the trigger.\r\n *\r\n * ### Usage\r\n *\r\n * `state` will declare an animation state with its associated styles\r\n * within the given trigger.\r\n *\r\n * - `stateNameExpr` can be one or more state names separated by commas.\r\n * - `styles` refers to the {@link style styling data} that will be persisted on the element once\r\n * the state has been reached.\r\n *\r\n * ```typescript\r\n * // \"void\" is a reserved name for a state and is used to represent\r\n * // the state in which an element is detached from from the application.\r\n * state(\"void\", style({ height: 0 }))\r\n *\r\n * // user-defined states\r\n * state(\"closed\", style({ height: 0 }))\r\n * state(\"open, visible\", style({ height: \"*\" }))\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction state(name, styles, options) {\r\n    return { type: 0 /* State */, name: name, styles: styles, options: options };\r\n}\r\n/**\r\n * `keyframes` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `keyframes` specifies a collection of {@link style style} entries each optionally characterized\r\n * by an `offset` value.\r\n *\r\n * ### Usage\r\n *\r\n * The `keyframes` animation function is designed to be used alongside the {@link animate animate}\r\n * animation function. Instead of applying animations from where they are currently to their\r\n * destination, keyframes can describe how each style entry is applied and at what point within the\r\n * animation arc (much like CSS Keyframe Animations do).\r\n *\r\n * For each `style()` entry an `offset` value can be set. Doing so allows to specify at what\r\n * percentage of the animate time the styles will be applied.\r\n *\r\n * ```typescript\r\n * // the provided offset values describe when each backgroundColor value is applied.\r\n * animate(\"5s\", keyframes([\r\n *   style({ backgroundColor: \"red\", offset: 0 }),\r\n *   style({ backgroundColor: \"blue\", offset: 0.2 }),\r\n *   style({ backgroundColor: \"orange\", offset: 0.3 }),\r\n *   style({ backgroundColor: \"black\", offset: 1 })\r\n * ]))\r\n * ```\r\n *\r\n * Alternatively, if there are no `offset` values used within the style entries then the offsets\r\n * will be calculated automatically.\r\n *\r\n * ```typescript\r\n * animate(\"5s\", keyframes([\r\n *   style({ backgroundColor: \"red\" }) // offset = 0\r\n *   style({ backgroundColor: \"blue\" }) // offset = 0.33\r\n *   style({ backgroundColor: \"orange\" }) // offset = 0.66\r\n *   style({ backgroundColor: \"black\" }) // offset = 1\r\n * ]))\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction keyframes(steps) {\r\n    return { type: 5 /* Keyframes */, steps: steps };\r\n}\r\n/**\r\n * `transition` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. If this information is new, please navigate to the {@link\r\n * Component#animations component animations metadata page} to gain a better understanding of\r\n * how animations in Angular are used.\r\n *\r\n * `transition` declares the {@link sequence sequence of animation steps} that will be run when the\r\n * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>\r\n * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting\r\n * and/or ending state).\r\n *\r\n * A function can also be provided as the `stateChangeExpr` argument for a transition and this\r\n * function will be executed each time a state change occurs. If the value returned within the\r\n * function is true then the associated animation will be run.\r\n *\r\n * Animation transitions are placed within an {@link trigger animation trigger}. For an transition\r\n * to animate to a state value and persist its styles then one or more {@link state animation\r\n * states} is expected to be defined.\r\n *\r\n * ### Usage\r\n *\r\n * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on\r\n * what the previous state is and what the current state has become. In other words, if a transition\r\n * is defined that matches the old/current state criteria then the associated animation will be\r\n * triggered.\r\n *\r\n * ```typescript\r\n * // all transition/state changes are defined within an animation trigger\r\n * trigger(\"myAnimationTrigger\", [\r\n *   // if a state is defined then its styles will be persisted when the\r\n *   // animation has fully completed itself\r\n *   state(\"on\", style({ background: \"green\" })),\r\n *   state(\"off\", style({ background: \"grey\" })),\r\n *\r\n *   // a transition animation that will be kicked off when the state value\r\n *   // bound to \"myAnimationTrigger\" changes from \"on\" to \"off\"\r\n *   transition(\"on => off\", animate(500)),\r\n *\r\n *   // it is also possible to do run the same animation for both directions\r\n *   transition(\"on <=> off\", animate(500)),\r\n *\r\n *   // or to define multiple states pairs separated by commas\r\n *   transition(\"on => off, off => void\", animate(500)),\r\n *\r\n *   // this is a catch-all state change for when an element is inserted into\r\n *   // the page and the destination state is unknown\r\n *   transition(\"void => *\", [\r\n *     style({ opacity: 0 }),\r\n *     animate(500)\r\n *   ]),\r\n *\r\n *   // this will capture a state change between any states\r\n *   transition(\"* => *\", animate(\"1s 0s\")),\r\n *\r\n *   // you can also go full out and include a function\r\n *   transition((fromState, toState) => {\r\n *     // when `true` then it will allow the animation below to be invoked\r\n *     return fromState == \"off\" && toState == \"on\";\r\n *   }, animate(\"1s 0s\"))\r\n * ])\r\n * ```\r\n *\r\n * The template associated with this component will make use of the `myAnimationTrigger` animation\r\n * trigger by binding to an element within its template code.\r\n *\r\n * ```html\r\n * <!-- somewhere inside of my-component-tpl.html -->\r\n * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\r\n * ```\r\n *\r\n * #### The final `animate` call\r\n *\r\n * If the final step within the transition steps is a call to `animate()` that **only** uses a\r\n * timing value with **no style data** then it will be automatically used as the final animation arc\r\n * for the element to animate itself to the final state. This involves an automatic mix of\r\n * adding/removing CSS styles so that the element will be in the exact state it should be for the\r\n * applied state to be presented correctly.\r\n *\r\n * ```\r\n * // start off by hiding the element, but make sure that it animates properly to whatever state\r\n * // is currently active for \"myAnimationTrigger\"\r\n * transition(\"void => *\", [\r\n *   style({ opacity: 0 }),\r\n *   animate(500)\r\n * ])\r\n * ```\r\n *\r\n * ### Using :enter and :leave\r\n *\r\n * Given that enter (insertion) and leave (removal) animations are so common, the `transition`\r\n * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*\r\n * => void` state changes.\r\n *\r\n * ```\r\n * transition(\":enter\", [\r\n *   style({ opacity: 0 }),\r\n *   animate(500, style({ opacity: 1 }))\r\n * ]),\r\n * transition(\":leave\", [\r\n *   animate(500, style({ opacity: 0 }))\r\n * ])\r\n * ```\r\n *\r\n * ### Boolean values\r\n * if a trigger binding value is a boolean value then it can be matched using a transition\r\n * expression that compares `true` and `false` or `1` and `0`.\r\n *\r\n * ```\r\n * // in the template\r\n * <div [@openClose]=\"open ? true : false\">...</div>\r\n *\r\n * // in the component metadata\r\n * trigger('openClose', [\r\n *   state('true', style({ height: '*' })),\r\n *   state('false', style({ height: '0px' })),\r\n *   transition('false <=> true', animate(500))\r\n * ])\r\n * ```\r\n *\r\n * ### Using :increment and :decrement\r\n * In addition to the :enter and :leave transition aliases, the :increment and :decrement aliases\r\n * can be used to kick off a transition when a numeric value has increased or decreased in value.\r\n *\r\n * ```\r\n * import {group, animate, query, transition, style, trigger} from '@angular/animations';\r\n * import {Component} from '@angular/core';\r\n *\r\n * @Component({\r\n *   selector: 'banner-carousel-component',\r\n *   styles: [`\r\n *     .banner-container {\r\n *        position:relative;\r\n *        height:500px;\r\n *        overflow:hidden;\r\n *      }\r\n *     .banner-container > .banner {\r\n *        position:absolute;\r\n *        left:0;\r\n *        top:0;\r\n *        font-size:200px;\r\n *        line-height:500px;\r\n *        font-weight:bold;\r\n *        text-align:center;\r\n *        width:100%;\r\n *      }\r\n *   `],\r\n *   template: `\r\n *     <button (click)=\"previous()\">Previous</button>\r\n *     <button (click)=\"next()\">Next</button>\r\n *     <hr>\r\n *     <div [@bannerAnimation]=\"selectedIndex\" class=\"banner-container\">\r\n *       <div class=\"banner\" *ngFor=\"let banner of banners\"> {{ banner }} </div>\r\n *     </div>\r\n *   `,\r\n *   animations: [\r\n *     trigger('bannerAnimation', [\r\n *       transition(\":increment\", group([\r\n *         query(':enter', [\r\n *           style({ left: '100%' }),\r\n *           animate('0.5s ease-out', style('*'))\r\n *         ]),\r\n *         query(':leave', [\r\n *           animate('0.5s ease-out', style({ left: '-100%' }))\r\n *         ])\r\n *       ])),\r\n *       transition(\":decrement\", group([\r\n *         query(':enter', [\r\n *           style({ left: '-100%' }),\r\n *           animate('0.5s ease-out', style('*'))\r\n *         ]),\r\n *         query(':leave', [\r\n *           animate('0.5s ease-out', style({ left: '100%' }))\r\n *         ])\r\n *       ]))\r\n *     ])\r\n *   ]\r\n * })\r\n * class BannerCarouselComponent {\r\n *   allBanners: string[] = ['1', '2', '3', '4'];\r\n *   selectedIndex: number = 0;\r\n *\r\n *   get banners() {\r\n *      return [this.allBanners[this.selectedIndex]];\r\n *   }\r\n *\r\n *   previous() {\r\n *     this.selectedIndex = Math.max(this.selectedIndex - 1, 0);\r\n *   }\r\n *\r\n *   next() {\r\n *     this.selectedIndex = Math.min(this.selectedIndex + 1, this.allBanners.length - 1);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction transition(stateChangeExpr, steps, options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };\r\n}\r\n/**\r\n * `animation` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language.\r\n *\r\n * `var myAnimation = animation(...)` is designed to produce a reusable animation that can be later\r\n * invoked in another animation or sequence. Reusable animations are designed to make use of\r\n * animation parameters and the produced animation can be used via the `useAnimation` method.\r\n *\r\n * ```\r\n * var fadeAnimation = animation([\r\n *   style({ opacity: '{{ start }}' }),\r\n *   animate('{{ time }}',\r\n *     style({ opacity: '{{ end }}'}))\r\n * ], { params: { time: '1000ms', start: 0, end: 1 }});\r\n * ```\r\n *\r\n * If parameters are attached to an animation then they act as **default parameter values**. When an\r\n * animation is invoked via `useAnimation` then parameter values are allowed to be passed in\r\n * directly. If any of the passed in parameter values are missing then the default values will be\r\n * used.\r\n *\r\n * ```\r\n * useAnimation(fadeAnimation, {\r\n *   params: {\r\n *     time: '2s',\r\n *     start: 1,\r\n *     end: 0\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * If one or more parameter values are missing before animated then an error will be thrown.\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction animation(steps, options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 8 /* Reference */, animation: steps, options: options };\r\n}\r\n/**\r\n * `animateChild` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. It works by allowing a queried element to execute its own\r\n * animation within the animation sequence.\r\n *\r\n * Each time an animation is triggered in angular, the parent animation\r\n * will always get priority and any child animations will be blocked. In order\r\n * for a child animation to run, the parent animation must query each of the elements\r\n * containing child animations and then allow the animations to run using `animateChild`.\r\n *\r\n * The example HTML code below shows both parent and child elements that have animation\r\n * triggers that will execute at the same time.\r\n *\r\n * ```html\r\n * <!-- parent-child.component.html -->\r\n * <button (click)=\"exp =! exp\">Toggle</button>\r\n * <hr>\r\n *\r\n * <div [@parentAnimation]=\"exp\">\r\n *   <header>Hello</header>\r\n *   <div [@childAnimation]=\"exp\">\r\n *       one\r\n *   </div>\r\n *   <div [@childAnimation]=\"exp\">\r\n *       two\r\n *   </div>\r\n *   <div [@childAnimation]=\"exp\">\r\n *       three\r\n *   </div>\r\n * </div>\r\n * ```\r\n *\r\n * Now when the `exp` value changes to true, only the `parentAnimation` animation will animate\r\n * because it has priority. However, using `query` and `animateChild` each of the inner animations\r\n * can also fire:\r\n *\r\n * ```ts\r\n * // parent-child.component.ts\r\n * import {trigger, transition, animate, style, query, animateChild} from '@angular/animations';\r\n * @Component({\r\n *   selector: 'parent-child-component',\r\n *   animations: [\r\n *     trigger('parentAnimation', [\r\n *       transition('false => true', [\r\n *         query('header', [\r\n *           style({ opacity: 0 }),\r\n *           animate(500, style({ opacity: 1 }))\r\n *         ]),\r\n *         query('@childAnimation', [\r\n *           animateChild()\r\n *         ])\r\n *       ])\r\n *     ]),\r\n *     trigger('childAnimation', [\r\n *       transition('false => true', [\r\n *         style({ opacity: 0 }),\r\n *         animate(500, style({ opacity: 1 }))\r\n *       ])\r\n *     ])\r\n *   ]\r\n * })\r\n * class ParentChildCmp {\r\n *   exp: boolean = false;\r\n * }\r\n * ```\r\n *\r\n * In the animation code above, when the `parentAnimation` transition kicks off it first queries to\r\n * find the header element and fades it in. It then finds each of the sub elements that contain the\r\n * `@childAnimation` trigger and then allows for their animations to fire.\r\n *\r\n * This example can be further extended by using stagger:\r\n *\r\n * ```ts\r\n * query('@childAnimation', stagger(100, [\r\n *   animateChild()\r\n * ]))\r\n * ```\r\n *\r\n * Now each of the sub animations start off with respect to the `100ms` staggering step.\r\n *\r\n * ## The first frame of child animations\r\n * When sub animations are executed using `animateChild` the animation engine will always apply the\r\n * first frame of every sub animation immediately at the start of the animation sequence. This way\r\n * the parent animation does not need to set any initial styling data on the sub elements before the\r\n * sub animations kick off.\r\n *\r\n * In the example above the first frame of the `childAnimation`'s `false => true` transition\r\n * consists of a style of `opacity: 0`. This is applied immediately when the `parentAnimation`\r\n * animation transition sequence starts. Only then when the `@childAnimation` is queried and called\r\n * with `animateChild` will it then animate to its destination of `opacity: 1`.\r\n *\r\n * Note that this feature designed to be used alongside {@link query query()} and it will only work\r\n * with animations that are assigned using the Angular animation DSL (this means that CSS keyframes\r\n * and transitions are not handled by this API).\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction animateChild(options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 9 /* AnimateChild */, options: options };\r\n}\r\n/**\r\n * `useAnimation` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. It is used to kick off a reusable animation that is created using {@link\r\n * animation animation()}.\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction useAnimation(animation, options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 10 /* AnimateRef */, animation: animation, options: options };\r\n}\r\n/**\r\n * `query` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language.\r\n *\r\n * query() is used to find one or more inner elements within the current element that is\r\n * being animated within the sequence. The provided animation steps are applied\r\n * to the queried element (by default, an array is provided, then this will be\r\n * treated as an animation sequence).\r\n *\r\n * ### Usage\r\n *\r\n * query() is designed to collect multiple elements and works internally by using\r\n * `element.querySelectorAll`. An additional options object can be provided which\r\n * can be used to limit the total amount of items to be collected.\r\n *\r\n * ```js\r\n * query('div', [\r\n *   animate(...),\r\n *   animate(...)\r\n * ], { limit: 1 })\r\n * ```\r\n *\r\n * query(), by default, will throw an error when zero items are found. If a query\r\n * has the `optional` flag set to true then this error will be ignored.\r\n *\r\n * ```js\r\n * query('.some-element-that-may-not-be-there', [\r\n *   animate(...),\r\n *   animate(...)\r\n * ], { optional: true })\r\n * ```\r\n *\r\n * ### Special Selector Values\r\n *\r\n * The selector value within a query can collect elements that contain angular-specific\r\n * characteristics\r\n * using special pseudo-selectors tokens.\r\n *\r\n * These include:\r\n *\r\n *  - Querying for newly inserted/removed elements using `query(\":enter\")`/`query(\":leave\")`\r\n *  - Querying all currently animating elements using `query(\":animating\")`\r\n *  - Querying elements that contain an animation trigger using `query(\"@triggerName\")`\r\n *  - Querying all elements that contain an animation triggers using `query(\"@*\")`\r\n *  - Including the current element into the animation sequence using `query(\":self\")`\r\n *\r\n *\r\n *  Each of these pseudo-selector tokens can be merged together into a combined query selector\r\n * string:\r\n *\r\n *  ```\r\n *  query(':self, .record:enter, .record:leave, @subTrigger', [...])\r\n *  ```\r\n *\r\n * ### Demo\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'inner',\r\n *   template: `\r\n *     <div [@queryAnimation]=\"exp\">\r\n *       <h1>Title</h1>\r\n *       <div class=\"content\">\r\n *         Blah blah blah\r\n *       </div>\r\n *     </div>\r\n *   `,\r\n *   animations: [\r\n *    trigger('queryAnimation', [\r\n *      transition('* => goAnimate', [\r\n *        // hide the inner elements\r\n *        query('h1', style({ opacity: 0 })),\r\n *        query('.content', style({ opacity: 0 })),\r\n *\r\n *        // animate the inner elements in, one by one\r\n *        query('h1', animate(1000, style({ opacity: 1 })),\r\n *        query('.content', animate(1000, style({ opacity: 1 })),\r\n *      ])\r\n *    ])\r\n *  ]\r\n * })\r\n * class Cmp {\r\n *   exp = '';\r\n *\r\n *   goAnimate() {\r\n *     this.exp = 'goAnimate';\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction query(selector, animation, options) {\r\n    if (options === void 0) {\r\n        options = null;\r\n    }\r\n    return { type: 11 /* Query */, selector: selector, animation: animation, options: options };\r\n}\r\n/**\r\n * `stagger` is an animation-specific function that is designed to be used inside of Angular's\r\n * animation DSL language. It is designed to be used inside of an animation {@link query query()}\r\n * and works by issuing a timing gap between after each queried item is animated.\r\n *\r\n * ### Usage\r\n *\r\n * In the example below there is a container element that wraps a list of items stamped out\r\n * by an ngFor. The container element contains an animation trigger that will later be set\r\n * to query for each of the inner items.\r\n *\r\n * ```html\r\n * <!-- list.component.html -->\r\n * <button (click)=\"toggle()\">Show / Hide Items</button>\r\n * <hr />\r\n * <div [@listAnimation]=\"items.length\">\r\n *   <div *ngFor=\"let item of items\">\r\n *     {{ item }}\r\n *   </div>\r\n * </div>\r\n * ```\r\n *\r\n * The component code for this looks as such:\r\n *\r\n * ```ts\r\n * import {trigger, transition, style, animate, query, stagger} from '@angular/animations';\r\n * @Component({\r\n *   templateUrl: 'list.component.html',\r\n *   animations: [\r\n *     trigger('listAnimation', [\r\n *        //...\r\n *     ])\r\n *   ]\r\n * })\r\n * class ListComponent {\r\n *   items = [];\r\n *\r\n *   showItems() {\r\n *     this.items = [0,1,2,3,4];\r\n *   }\r\n *\r\n *   hideItems() {\r\n *     this.items = [];\r\n *   }\r\n *\r\n *   toggle() {\r\n *     this.items.length ? this.hideItems() : this.showItems();\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * And now for the animation trigger code:\r\n *\r\n * ```ts\r\n * trigger('listAnimation', [\r\n *   transition('* => *', [ // each time the binding value changes\r\n *     query(':leave', [\r\n *       stagger(100, [\r\n *         animate('0.5s', style({ opacity: 0 }))\r\n *       ])\r\n *     ]),\r\n *     query(':enter', [\r\n *       style({ opacity: 0 }),\r\n *       stagger(100, [\r\n *         animate('0.5s', style({ opacity: 1 }))\r\n *       ])\r\n *     ])\r\n *   ])\r\n * ])\r\n * ```\r\n *\r\n * Now each time the items are added/removed then either the opacity\r\n * fade-in animation will run or each removed item will be faded out.\r\n * When either of these animations occur then a stagger effect will be\r\n * applied after each item's animation is started.\r\n *\r\n * @experimental Animation support is experimental.\r\n */\r\nfunction stagger(timings, animation) {\r\n    return { type: 12 /* Stagger */, timings: timings, animation: animation };\r\n}\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction scheduleMicroTask(cb) {\r\n    Promise.resolve(null).then(cb);\r\n}\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @experimental Animation support is experimental.\r\n */\r\nvar NoopAnimationPlayer = /*@__PURE__*/ (function () {\r\n    function NoopAnimationPlayer(duration, delay) {\r\n        if (duration === void 0) {\r\n            duration = 0;\r\n        }\r\n        if (delay === void 0) {\r\n            delay = 0;\r\n        }\r\n        this._onDoneFns = [];\r\n        this._onStartFns = [];\r\n        this._onDestroyFns = [];\r\n        this._started = false;\r\n        this._destroyed = false;\r\n        this._finished = false;\r\n        this.parentPlayer = null;\r\n        this.totalTime = duration + delay;\r\n    }\r\n    NoopAnimationPlayer.prototype._onFinish = function () {\r\n        if (!this._finished) {\r\n            this._finished = true;\r\n            this._onDoneFns.forEach(function (fn) { return fn(); });\r\n            this._onDoneFns = [];\r\n        }\r\n    };\r\n    NoopAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\r\n    NoopAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\r\n    NoopAnimationPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };\r\n    NoopAnimationPlayer.prototype.hasStarted = function () { return this._started; };\r\n    NoopAnimationPlayer.prototype.init = function () { };\r\n    NoopAnimationPlayer.prototype.play = function () {\r\n        if (!this.hasStarted()) {\r\n            this._onStart();\r\n            this.triggerMicrotask();\r\n        }\r\n        this._started = true;\r\n    };\r\n    /* @internal */\r\n    NoopAnimationPlayer.prototype.triggerMicrotask = function () {\r\n        var _this = this;\r\n        scheduleMicroTask(function () { return _this._onFinish(); });\r\n    };\r\n    NoopAnimationPlayer.prototype._onStart = function () {\r\n        this._onStartFns.forEach(function (fn) { return fn(); });\r\n        this._onStartFns = [];\r\n    };\r\n    NoopAnimationPlayer.prototype.pause = function () { };\r\n    NoopAnimationPlayer.prototype.restart = function () { };\r\n    NoopAnimationPlayer.prototype.finish = function () { this._onFinish(); };\r\n    NoopAnimationPlayer.prototype.destroy = function () {\r\n        if (!this._destroyed) {\r\n            this._destroyed = true;\r\n            if (!this.hasStarted()) {\r\n                this._onStart();\r\n            }\r\n            this.finish();\r\n            this._onDestroyFns.forEach(function (fn) { return fn(); });\r\n            this._onDestroyFns = [];\r\n        }\r\n    };\r\n    NoopAnimationPlayer.prototype.reset = function () { };\r\n    NoopAnimationPlayer.prototype.setPosition = function (p) { };\r\n    NoopAnimationPlayer.prototype.getPosition = function () { return 0; };\r\n    /* @internal */\r\n    NoopAnimationPlayer.prototype.triggerCallback = function (phaseName) {\r\n        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\r\n        methods.forEach(function (fn) { return fn(); });\r\n        methods.length = 0;\r\n    };\r\n    return NoopAnimationPlayer;\r\n}());\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar AnimationGroupPlayer = /*@__PURE__*/ (function () {\r\n    function AnimationGroupPlayer(_players) {\r\n        var _this = this;\r\n        this._onDoneFns = [];\r\n        this._onStartFns = [];\r\n        this._finished = false;\r\n        this._started = false;\r\n        this._destroyed = false;\r\n        this._onDestroyFns = [];\r\n        this.parentPlayer = null;\r\n        this.totalTime = 0;\r\n        this.players = _players;\r\n        var doneCount = 0;\r\n        var destroyCount = 0;\r\n        var startCount = 0;\r\n        var total = this.players.length;\r\n        if (total == 0) {\r\n            scheduleMicroTask(function () { return _this._onFinish(); });\r\n        }\r\n        else {\r\n            this.players.forEach(function (player) {\r\n                player.onDone(function () {\r\n                    if (++doneCount == total) {\r\n                        _this._onFinish();\r\n                    }\r\n                });\r\n                player.onDestroy(function () {\r\n                    if (++destroyCount == total) {\r\n                        _this._onDestroy();\r\n                    }\r\n                });\r\n                player.onStart(function () {\r\n                    if (++startCount == total) {\r\n                        _this._onStart();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        this.totalTime = this.players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);\r\n    }\r\n    AnimationGroupPlayer.prototype._onFinish = function () {\r\n        if (!this._finished) {\r\n            this._finished = true;\r\n            this._onDoneFns.forEach(function (fn) { return fn(); });\r\n            this._onDoneFns = [];\r\n        }\r\n    };\r\n    AnimationGroupPlayer.prototype.init = function () { this.players.forEach(function (player) { return player.init(); }); };\r\n    AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\r\n    AnimationGroupPlayer.prototype._onStart = function () {\r\n        if (!this.hasStarted()) {\r\n            this._started = true;\r\n            this._onStartFns.forEach(function (fn) { return fn(); });\r\n            this._onStartFns = [];\r\n        }\r\n    };\r\n    AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\r\n    AnimationGroupPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };\r\n    AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };\r\n    AnimationGroupPlayer.prototype.play = function () {\r\n        if (!this.parentPlayer) {\r\n            this.init();\r\n        }\r\n        this._onStart();\r\n        this.players.forEach(function (player) { return player.play(); });\r\n    };\r\n    AnimationGroupPlayer.prototype.pause = function () { this.players.forEach(function (player) { return player.pause(); }); };\r\n    AnimationGroupPlayer.prototype.restart = function () { this.players.forEach(function (player) { return player.restart(); }); };\r\n    AnimationGroupPlayer.prototype.finish = function () {\r\n        this._onFinish();\r\n        this.players.forEach(function (player) { return player.finish(); });\r\n    };\r\n    AnimationGroupPlayer.prototype.destroy = function () { this._onDestroy(); };\r\n    AnimationGroupPlayer.prototype._onDestroy = function () {\r\n        if (!this._destroyed) {\r\n            this._destroyed = true;\r\n            this._onFinish();\r\n            this.players.forEach(function (player) { return player.destroy(); });\r\n            this._onDestroyFns.forEach(function (fn) { return fn(); });\r\n            this._onDestroyFns = [];\r\n        }\r\n    };\r\n    AnimationGroupPlayer.prototype.reset = function () {\r\n        this.players.forEach(function (player) { return player.reset(); });\r\n        this._destroyed = false;\r\n        this._finished = false;\r\n        this._started = false;\r\n    };\r\n    AnimationGroupPlayer.prototype.setPosition = function (p) {\r\n        var timeAtPosition = p * this.totalTime;\r\n        this.players.forEach(function (player) {\r\n            var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;\r\n            player.setPosition(position);\r\n        });\r\n    };\r\n    AnimationGroupPlayer.prototype.getPosition = function () {\r\n        var min = 0;\r\n        this.players.forEach(function (player) {\r\n            var p = player.getPosition();\r\n            min = Math.min(p, min);\r\n        });\r\n        return min;\r\n    };\r\n    AnimationGroupPlayer.prototype.beforeDestroy = function () {\r\n        this.players.forEach(function (player) {\r\n            if (player.beforeDestroy) {\r\n                player.beforeDestroy();\r\n            }\r\n        });\r\n    };\r\n    /* @internal */\r\n    AnimationGroupPlayer.prototype.triggerCallback = function (phaseName) {\r\n        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\r\n        methods.forEach(function (fn) { return fn(); });\r\n        methods.length = 0;\r\n    };\r\n    return AnimationGroupPlayer;\r\n}());\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar ɵPRE_STYLE = '!';\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all animation APIs of the animation package.\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of this package.\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// This file is not used to build this module. It is only used during editing\r\n// by the TypeScript language service and during build for verification. `ngc`\r\n// replaces this file with production index.ts when it rewrites private symbol\r\n// names.\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\nexport { AnimationBuilder, AnimationFactory, AUTO_STYLE, animate, animateChild, animation, group, keyframes, query, sequence, stagger, state, style, transition, trigger, useAnimation, NoopAnimationPlayer, ɵPRE_STYLE, AnimationGroupPlayer as ɵAnimationGroupPlayer };\r\n//# sourceMappingURL=animations.js.map\r\n",null]}